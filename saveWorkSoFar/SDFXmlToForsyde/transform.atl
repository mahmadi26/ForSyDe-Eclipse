-- @nsURI forsyde=http://forsyde.ict.kth.se/core/forsyde
-- @nsURI XML=http://www.eclipse.org/MoDisco/Xml/0.1.incubation/XML

module transform;
create OUT : forsyde from IN : XML;

rule sdfToSystem {
	from 
		inSDF : XML!Root 
	to 
		outSys : forsyde!System (
			processNetworks <- inSDF.children -> select (e | e.name = 'applicationGraph' )	
		) 
		
}

rule appGraphToPN {
	from 
		inAppGraph : XML!Element ( 
			inAppGraph.name = 'applicationGraph'
		)
	using {
		sdf : XML!Elemet = inAppGraph.children -> select (e | e.name = 'sdf') -> first() ; 	
		actors : Sequence(XML!Element) = sdf.children -> select (e | e.name = 'actor') ;
		chWithInitials : Sequence(XML!Element) = sdf.children ->select (e | e.name = 'channel') -> select (ch |not (ch.attribute('initialTokens') = OclUndefined) ) ;
		}
	to 
		outPN : forsyde!ProcessNetwork (
			name <- 'top'  
			,processes <- Sequence {actors
								  ,
								  chWithInitials -> collect(ch | thisModule.resolveTemp (ch,'delay'))
								  } 							
			
			,signals <- Sequence {sdf.children ->select (e | e.name = 'channel')
							     , 
								 chWithInitials -> collect (ch | thisModule.resolveTemp(ch , 'sigFromDelay') )
								 }
		)
}


rule actorToLeafProcess {
	from 
		actor : XML!Element ( 
		 if actor.name = 'actor'
		 then 
		 	if ((actor.children-> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'out').size()) <=1 )
			then true 
			else false 
			endif 
		else false 
		endif
		)
	using {
		-- following causes problem in actors with no input port
		inports : Sequence(XML!Element) = actor.children -> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'in');	
		-- following causes error in processes with no output ports
		oport : XML!Element = actor.children -> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'out')->first();			

	}
	to 
		outPr : forsyde!LeafProcess (
			name <- actor.attribute('name').value  + '__' + actor.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children
					 ->select (e | e.name = 'actorProperties') -> select (ap | ap.attribute('actor').value = actor.attribute('name').value)
					 ->first().children->select (e | e.name = 'processor')->first().children -> select (e | e.name = 'executionTime') -> first().attribute('time').value
			,ports <- actor.children -> select (e | e.name = 'port') 				
			,processConstructor <- thisModule.processConstructor('comb'+ inports.size().toString())
			,constructorArguments <- Sequence {thisModule.constructorArgument('_func',outPr.name + '_func'),thisModule.constructorArgument('o1toks',if (oport = OclUndefined) then '-1' else  oport.attribute('rate').value.toString() endif )
												,inports -> collect (a |
													thisModule.constructorArgument('i'.concat(inports->indexOf(a).toString()).concat('toks'),a.attribute('rate').value.toString()))
												}->flatten()
			
		)
	
}
 
 
rule actorToCompositeProcess {
	from 
		actor : XML!Element ( 
		 if actor.name = 'actor'
		 then 
		 	if ((actor.children -> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'out').size()) >1 )
			then true 
			else false   
			endif 
		else false 
		endif
		)
	using {
		-- following causes problem in actors with no input port
		inports : Sequence(XML!Element) = actor.children -> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'in');	
	    
		oports : XML!Element = actor.children -> flatten() -> select (e | e.name = 'port') -> select (p | p.attribute('type').value = 'out');			

	}
	to outCPr : forsyde!CompositeProcess (
			name <- actor.attribute('name').value 
			,ports <- actor.children -> select (e | e.name = 'port') 				
			,component <- outPN
	   )
	   ,outPN : forsyde!ProcessNetwork (  
			processes <- Sequence {outLeaf, outUnzip} 							
			,signals <- outSig	
	   )
	   ,outLeaf : forsyde!LeafProcess (
	   		name <- actor.attribute('name').value +'_oneOutput'+ '__' + actor.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children
					->select (e | e.name = 'actorProperties') -> select (ap | ap.attribute('actor').value = actor.attribute('name').value)
					->first().children->select (e | e.name = 'processor')->first().children -> select (e | e.name = 'executionTime') -> first().attribute('time').value
			,ports <- Sequence {outP , inports -> collect (ip | thisModule.resolveTemp(ip,'leafInP'))} 				
			,processConstructor <- thisModule.processConstructor('comb'+ inports.size().toString())
			,constructorArguments <- Sequence {thisModule.constructorArgument('_func',outLeaf.name+'_func')
													,thisModule.constructorArgument('o1toks','1')
													,inports -> collect (a |
													thisModule.constructorArgument('i'.concat(inports->indexOf(a).toString()).concat('toks'),a.attribute('rate').value.toString()))
												}->flatten()
	   )
	   ,outUnzip : forsyde!LeafProcess (
	   	name <- actor.attribute('name').value + '_unzip' 
			,ports <- Sequence {oports-> collect (op | thisModule.resolveTemp(op,'unzipOutP')),unzipIP}  				
			,processConstructor <- thisModule.processConstructor('unzipN')
			,constructorArguments <- Sequence {thisModule.constructorArgument('_func','tuple_vector_func')
												,oports -> collect (a |
													thisModule.constructorArgument('o'.concat(oports->indexOf(a).toString()).concat('toks'),a.attribute('rate').value.toString()))
												}->flatten()
	   )
	   ,outSig : forsyde!Signal (
	   		name <- actor.attribute('name').value + '_toUnzip' 
			,moc <- 'SDF' 
			,dataType <- 'tuple<vector<int>...>' 
			,sourceProcess <- outLeaf
			,targetProcess <- outUnzip  					   
			,sourcePort <- outP
			,targetPort <- unzipIP	   
			)
	   ,outP : forsyde!OutputPort (
	   		name <-  actor.attribute('name').value + '_out'
			,moc <- 'SDF'
			,dataType <- 'tuple<int...>'	
	   )
	   ,unzipIP : forsyde!InputPort (
	   		name <-  outUnzip.name + '_in'
	   		,moc <- 'SDF'
			,dataType <- 'tuple<int...>'
	   )
}



rule channelToSignalNoInitials {
	from 
		 ch : XML!Element 
		(
			if  ch.name = 'channel'
			then if ch.attribute('initialTokens') = OclUndefined
				 then true
				 else false 
				 endif 
			else false 
			endif
		)
	to 
		 Sig : forsyde!Signal (
			name <- ch.attribute('name').value 	
			,moc <- 'SDF' 
			,dataType <- 'array<int,' + ch.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | e.attribute('channel').value = ch.attribute('name').value)->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>' 
			,sourceProcess <- ch.parent.children -> select (e | e.name = 'actor') -> select (a | ch.attribute('srcActor').value = a.attribute('name').value) -> first()
			,targetProcess <- ch.parent.children -> select (e | e.name = 'actor') -> select (a | ch.attribute('dstActor').value = a.attribute('name').value) -> first()
			,sourcePort <- ch.parent.children -> select (e | e.name = 'actor') 
							-> select (a | ch.attribute('srcActor').value = a.attribute('name').value) -> first().children 
							->select (e | e.name = 'port') -> select (p | ch.attribute('srcPort').value = p.attribute('name').value)->first()
			,targetPort <- ch.parent.children -> select (e | e.name = 'actor') 
							-> select (a | ch.attribute('dstActor').value = a.attribute('name').value) -> first().children 
							->select (e | e.name = 'port') -> select (p | ch.attribute('dstPort').value = p.attribute('name').value)->first()
		)
	
}

rule channelToSignalInitials {
	from 
		 ch : XML!Element 
		(
			if  ch.name = 'channel'
			then if ch.attribute('initialTokens') = OclUndefined
				 then false 
				 else true 
				 endif 
			else false 
			endif
		)
	to 
		 sigToDelay : forsyde!Signal (
			name <- ch.attribute('name').value + '_beforeD' 	
			,moc <- 'SDF' 
			,dataType <- 'array<int,' + ch.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | e.attribute('channel').value = ch.attribute('name').value)->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>' 
			,sourceProcess <- ch.parent.children -> select (e | e.name = 'actor') -> select (a | ch.attribute('srcActor').value = a.attribute('name').value) -> first()
			,targetProcess <- delay
			,sourcePort <- ch.parent.children -> select (e | e.name = 'actor') 
							-> select (a | ch.attribute('srcActor').value = a.attribute('name').value) -> first().children 
							->select (e | e.name = 'port') -> select (p | ch.attribute('srcPort').value = p.attribute('name').value)->first()
			,targetPort <- delayInP
		)
		,sigFromDelay : forsyde!Signal (
			name <- ch.attribute('name').value + '_afterD' 	
			,moc <- 'SDF' 
			,dataType <- 'array<int,' + ch.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | e.attribute('channel').value = ch.attribute('name').value)->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>' 
			,sourceProcess <- delay
			,targetProcess <- ch.parent.children -> select (e | e.name = 'actor') -> select (a | ch.attribute('dstActor').value = a.attribute('name').value) -> first()
			,sourcePort <- delayOutP
			,targetPort <- ch.parent.children -> select (e | e.name = 'actor') 
							-> select (a | ch.attribute('dstActor').value = a.attribute('name').value) -> first().children 
							->select (e | e.name = 'port') -> select (p | ch.attribute('dstPort').value = p.attribute('name').value)->first()
		)
		,delay : forsyde!LeafProcess (
			name <- 'delay' + ch.attribute('name').value 
			,ports <- Sequence {delayOutP,delayInP}  				
			,processConstructor <- thisModule.processConstructor('delayn')
			,constructorArguments <- Sequence {thisModule.constructorArgument('init_val','{0}')
											   ,
											   thisModule.constructorArgument('n',ch.attribute('initialTokens').value.toString())
											   }
			
		)
		, delayInP : forsyde!InputPort ( 
			name <-  delay.name + '_in'
			,moc <- 'SDF'
			,dataType <- 'int'	
		)
		,delayOutP : forsyde!OutputPort (
			name <-  delay.name + '_out'
			,moc <- 'SDF'
			,dataType <- 'int'		)
	
}

rule portsToInPorts {
	from 
		p : XML!Element (
			if p.name = 'port'
			then if p.attribute('type').value = 'in'
				 then true 
				 else false 
				 endif 
			else false 
			endif
		) 
	to 
		outP : forsyde!InputPort (
			name <-  p.attribute('name').value 
			,moc <- 'SDF'
			,dataType <- 'array<int,' + p.parent.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | (e.attribute('channel').value) = (p.parent.parent.children->select(ch | ch.name = 'channel')->select(ch | ch.attribute('dstPort').value = p.attribute('name').value)->first().attribute('name').value))->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>'	
		)
		,leafInP : forsyde!InputPort (
			name <-  p.attribute('name').value + '_leaf' 
			,moc <- 'SDF'
			,dataType <- 'array<int,' + p.parent.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | (e.attribute('channel').value) = (p.parent.parent.children->select(ch | ch.name = 'channel')->select(ch | ch.attribute('dstPort').value = p.attribute('name').value)->first().attribute('name').value))->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>'
			,boundPort <- outP
			,boundProcess <- p.parent
		)
}
rule portsToOutPorts {
	from 
		p : XML!Element (
			if p.name = 'port'
			then if p.attribute('type').value = 'out'
				 then true 
				 else false 
				 endif 
			else false 
			endif
		) 
	to 
		outP : forsyde!OutputPort (
			name <-  p.attribute('name').value 
			,moc <- 'SDF'
			,dataType <- 'array<int,' + p.parent.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | (e.attribute('channel').value) = (p.parent.parent.children->select(ch | ch.name = 'channel')->select(ch | ch.attribute('srcPort').value = p.attribute('name').value)->first().attribute('name').value))->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>'	
		)
		,unzipOutP : forsyde!OutputPort (
			name <-  p.attribute('name').value + '_unzip' 
			,moc <- 'SDF'
			,dataType <- 'array<int,' + p.parent.parent.parent.children -> select (e | e.name = 'sdfProperties')->first().children -> select (e | e.name = 'channelProperties')->select (e | (e.attribute('channel').value) = (p.parent.parent.children->select(ch | ch.name = 'channel')->select(ch | ch.attribute('srcPort').value = p.attribute('name').value)->first().attribute('name').value))->first().children -> select (e | e.name = 'tokenSize') -> first().attribute('sz').value.toString() + '>'
			,boundPort <- outP
			,boundProcess <- p.parent
		)
}









-- lazy rules 



lazy rule processConstructor {
	from 
		pc : String 
	to 
		outPC : forsyde!ProcessConstructor (
			name <- thisModule.trim(pc)  
			,moc <- 'SDF'
		)
}

lazy rule constructorArgument {
	from 
		inName : String
		,inValue : String
	to 
		outPC : forsyde!ConstructorArgument (
			name <- inName 
			,value <- inValue
		)
}



-- helpers

helper def : trim(s : String) : String = 
	if s = 'comb1' 
	then 'comb'
	else s
	endif 
	
;
 
helper context XML!Element def : attribute(attName: String) : XML!Attribute = 
	self.children->select(a | a.name=attName)->first()
;


helper def : findProc(ss : XML!Element, lookupProcess : String) : XML!Element = 
	ss.parent.children->select(e | e.oclIsTypeOf(XML!Element))
		->select(p | p.attribute('name').value = ss.attribute(lookupProcess).value)->first()
;

helper def : findTargetPort(ss : XML!Element, lookupProcess : String, lookupPort : String) : XML!Element = 
	thisModule.findProc(ss, lookupProcess).children->select(p | p.name = 'port')
		->select(p | p.attribute('name').value = ss.attribute(lookupPort).value)->first()
;

helper def : findSourcePort(ss : XML!Element, lookupProcess : String, lookupPort : String) : XML!Element = 
	thisModule.findProc(ss, lookupProcess).children->select(p | p.name = 'port')
		->select(p | p.attribute('type').value = 'out')->first()
;