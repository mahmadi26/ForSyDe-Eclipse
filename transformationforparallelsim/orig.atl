-- @nsURI forsyde=http://forsyde.ict.kth.se/core/forsyde
-- @nsURI XML=http://www.eclipse.org/am3/2007/XML

module orig;
create    OUT1:forsyde
	   	, OUT2:forsyde
--		, OUT3:forsyde
--		, OUT4:forsyde
--		, OUT5:forsyde
--		, OUT6:forsyde
--		, OUT7:forsyde
--		, OUT8:forsyde
--		, OUT9:forsyde
--		, OUT10:forsyde
--		, OUT11:forsyde
--		, OUT12:forsyde
--		, OUT13:forsyde
--		, OUT14:forsyde
--		, OUT15:forsyde
--		, OUT16:forsyde
		from
		IN1: XML ,
		IN2: forsyde ;

rule startDivisioning {
	from
		ss : forsyde!System
		,xmlroot : XML!Root
	to
		ts1 : forsyde!System in OUT1 (
			processNetworks <- thisModule.copyProcessNetwork(ss.processNetworks->first(),xmlroot)
		)
		,ts2 : forsyde!System in OUT2 (
			processNetworks <- thisModule.copyProcessNetwork(ss.processNetworks->first(),xmlroot)
		)
}

lazy rule copyProcessNetwork {
	from
		spn : forsyde!ProcessNetwork
		,inxmlroot : XML!Root

	to
		tpn : forsyde!ProcessNetwork (
			 name <- spn.name
			,processes <- spn.processes->select(pr | inxmlroot.children->select(x | x.name ='Element')->
												   select(y | y.attribute('processor').value.toInteger() = thisModule.id)->
											       exists(z | z.attribute('process').value = pr.name))->
												   collect(p|thisModule.CopyLeafProcess(p)) ->
												   union(spn.signals ->select ( k |thisModule.senderProcess(k,inxmlroot))->
												   collect (n | thisModule.copySenderProcess(n)))->
												   union(spn.signals ->select ( k |thisModule.recieverProcess(k,inxmlroot))->
												   collect (n | thisModule.copyRecieverProcess(n)))


			,ports <- thisModule.resolvePorts((spn.ports-> select(u | thisModule.boundedProcessesPorts(spn,inxmlroot,tpn.processes)->includes(u))
												->collect (k| if k.oclIsTypeOf(forsyde!InputPort) then
												thisModule.CopyInputPort(k)
												else
												thisModule.CopyOutputPort(k)
												endif)-> union (spn.signals
													  -> select (n | thisModule.inPortCreatingSignals(n,inxmlroot) )
													  -> collect (n2 | thisModule.createdInPNPorts(n2)))
													  -> union (spn.signals
													  -> select (m | thisModule.outPortCreatingSignals(m,inxmlroot) )
													  -> collect (m2 | thisModule.createdOutPNPorts(m2)))),tpn.processes)

--			,signals <- spn.signals->reject(s | thisModule.deleteSignal(s,inxmlroot))->collect (k | thisModule.CopySignal(k))
																					 ->union(thisModule.createdSignals(spn.signals,inxmlroot))



		)
		do
		{

			thisModule.id <- thisModule.id +1 ;

		}

}

lazy rule resolvePortsTempIn {
	from
		 p : forsyde!InputPort
		,pr: forsyde!Process
	to
		 tp : forsyde!InputPort (

				name <- p.name,
				dataType <- p.dataType,
				moc <- p.moc,
				boundProcess <- pr,
				boundPort <- pr.ports->select ( k | k.name.startsWith('inPar'))->first()
			)

}
lazy rule resolvePortsTempOut {
	from
		 p : forsyde!OutputPort
		,pr: forsyde!Process
	to
		 tp : forsyde!OutputPort (

				name <- p.name,
				dataType <- p.dataType,
				moc <- p.moc,
				boundProcess <- pr,
				boundPort <- pr.ports->select ( k | k.name.startsWith('outPar'))->first()
			)

}


lazy rule copySenderProcess {
	from
		s: forsyde!Signal
	to
		spr: forsyde!LeafProcess (
		name <- s.sourceProcess.name.concat('prime')
		,processConstructor <- thisModule.senderConstructor(thisModule.senderConstructor1)
		,constructorArguments <- thisModule.senderArgument(thisModule.senderArgument1)
		,ports <- Sequence{s.sourcePort} ->collect(p | thisModule.CopyInputPort1(p)) -> union(Sequence{s.targetPort} ->
																				collect(p | thisModule.CopyOutputPort1(p)))

		)
}

lazy rule copyRecieverProcess {
	from
		s: forsyde!Signal
	to
		spr: forsyde!LeafProcess (
		name <- s.targetProcess.name.concat('prime')
		,processConstructor <- thisModule.recieverConstructor(thisModule.senderConstructor1)
		,constructorArguments <- thisModule.recieverArgument(thisModule.recieverArgument1)
		,ports <- Sequence{s.sourcePort} ->collect(p | thisModule.CopyInputPort1(p)) -> union(Sequence{s.sourcePort} ->
																				collect(p | thisModule.CopyOutputPort1(p)))
		)
}




lazy rule senderConstructor {
	from
		spc : forsyde!ProcessConstructor
	to
		tpc : forsyde!ProcessConstructor (
			name <- 'sender',
			moc <- 'SY'
		)
}
lazy rule recieverConstructor {
	from
		spc : forsyde!ProcessConstructor
	to
		tpc : forsyde!ProcessConstructor (
			name <- 'reciver',
			moc <- 'SY'
		)
}

lazy rule senderArgument {
	from
		sca : forsyde!ConstructorArgument
	to
		tca : forsyde!ConstructorArgument (
			name <- 'rank',
			type <- 'Estring',
			value <- thisModule.syncid.toString()
		)
}
lazy rule recieverArgument {
	from
		sca : forsyde!ConstructorArgument
	to
		tca : forsyde!ConstructorArgument (
			name <- 'rank',
			type <- 'Estring',
			value <- thisModule.syncid.toString()
		)
}


lazy rule CopyInputPort1 {
	from
		sp : forsyde!OutputPort
	to
		tp : forsyde!InputPort (
			name <- 'inPar'.concat(sp.name).concat(thisModule.id.toString()),
			dataType <- sp.dataType,
			moc <- sp.moc

		)
}

lazy rule CopyOutputPort1 {
	from
		sp : forsyde!InputPort
	to
		tp : forsyde!OutputPort (
			name <- 'outPar'.concat(sp.name).concat(thisModule.id.toString()),
			dataType <- sp.dataType,
			moc <- sp.moc
		)
}


lazy rule createdInPNPorts {
	from
		s : forsyde!Signal
	to
		sp : forsyde!InputPort
		(
			 name <- s.targetProcess.name.concat('prime')
			,dataType <- s.dataType
			,moc <- s.moc
		)
}

lazy rule createdOutPNPorts {
	from
		s : forsyde!Signal
	to
		sp : forsyde!OutputPort
		(
			 name <- s.sourceProcess.name.concat('prime')
			,dataType <- s.dataType
			,moc <- s.moc
		)
}

lazy rule CopyLeafProcess {
	from
		sp : forsyde!LeafProcess
	to
		tp : forsyde!LeafProcess  (
			name <- sp.name,
			processConstructor <- thisModule.CopyProcessConstructor(sp.processConstructor),
			constructorArguments <- sp.constructorArguments->collect(ca | thisModule.CopyConstructorArgument(ca)),
			ports <- sp.ports->collect(p | 	if p.oclIsTypeOf(forsyde!InputPort) then
												thisModule.CopyInputPort(p)
											else
												thisModule.CopyOutputPort(p)
											endif)
		)
}

lazy rule CopyInputPort {
	from
		sp : forsyde!InputPort
	to
		tp : forsyde!InputPort (
			name <- sp.name,
			dataType <- sp.dataType,
			moc <- sp.moc
		)
}

lazy rule CopyOutputPort {
	from
		sp : forsyde!OutputPort
	to
		tp : forsyde!OutputPort (
			name <- sp.name,
			dataType <- sp.dataType,
			moc <- sp.moc
		)
}

lazy rule CopySignal {
	from
		sp : forsyde!Signal
	to
		tp : forsyde!Signal (
			name <- sp.name,
			dataType <- sp.dataType,
			moc <- sp.moc--,
--			sourceProcess <- sp.sourceProcess,--FIXME: point to where?
--			sourcePort <- sp.sourcePort,--FIXME: point to where?
--			targetProcess <- sp.targetProcess,--FIXME: point to where?
--			targetPort <- sp.targetPort--FIXME: point to where?
		)
}

lazy rule CopyProcessConstructor {
	from
		spc : forsyde!ProcessConstructor
	to
		tpc : forsyde!ProcessConstructor (
			name <- spc.name,
			moc <- spc.moc
		)
}

lazy rule CopyConstructorArgument {
	from
		sca : forsyde!ConstructorArgument
	to
		tca : forsyde!ConstructorArgument (
			name <- sca.name,
			type <- sca.type,
			value <- sca.value
		)
}


helper context XML!Element def : attribute(attName: String) : XML!Attribute =
	self.children->select(a | a.name=attName)->first()
;

helper def : xmlelement :Set(XML!Element) = OclUndefined;
helper def : id :Integer = 1;
helper def : syncid : Integer = 1 ;
helper def : numPorts :Integer = 0;

helper def : boundedProcessesPorts(origPN: forsyde!ProcessNetwork, inxmlroot : XML!Root,origProc : forsyde!LeafProcess)
				: Sequence(forsyde!Port) =  let a : Set (forsyde!Port) = origProc
													->select (z | inxmlroot.children->select(x | x.name ='Element')
			                    				    ->select(y | y.attribute('processor').value.toInteger() = thisModule.id)
													->exists (x | x.attribute ('process').value = z.name))-> collect (e | e.ports)
													->flatten()
				in  origPN.ports  -> select (m | (a->includes(m.boundPort))) ;


helper def : inPortCreatingSignals(s : forsyde!Signal ,inxmlroot : XML!Root ) : Boolean
	= let b : Boolean = (not ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value) = (inxmlroot.children->select(q | q.name ='Element')
							  	  ->select(w | w.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value)))
				in if (b = true) then if ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value.toInteger()) = thisModule.id)
				   			then true
				   			else false endif
				   else false endif
		   ;
helper def : outPortCreatingSignals(s : forsyde!Signal ,inxmlroot : XML!Root ) : Boolean
	= let b : Boolean = not ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value) = (inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value))
				in if (b = true) then if ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value.toInteger()) = thisModule.id)
				   			then true
				   			else false endif
				   else false endif
		   ;
helper def : deleteSignal (s:forsyde!Signal , inxmlroot : XML!Root) : Boolean
	= let b : Boolean = not ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value) = (inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value))
				in if b = true then true else if not ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value.toInteger()) = thisModule.id)
								  			  then true else false endif
					endif
								  ;
helper def : senderProcess (s:forsyde!Signal , inxmlroot : XML!Root) : Boolean
	= let b : Boolean =  ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value) = (inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value))
				in if (b = true) then false  else if  ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value.toInteger()) = thisModule.id)
												  then true else false endif
					endif ;

helper def : recieverProcess (s:forsyde!Signal , inxmlroot : XML!Root) : Boolean
	= let b : Boolean =  ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value) = (inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.sourceProcess.name)
								  ->first().attribute('processor').value))
				in if (b = true) then false  else if  ((inxmlroot.children->select(x | x.name ='Element')
							  	  ->select(y | y.attribute('process').value = s.targetProcess.name)
								  ->first().attribute('processor').value.toInteger()) = thisModule.id)
												  then true else false endif
					endif ;

helper def : senderConstructor1 : forsyde!ProcessConstructor = OclUndefined;
helper def : recieverConstructor1 : forsyde!ProcessConstructor = OclUndefined;
helper def : senderArgument1 : forsyde!ProcessArgument = OclUndefined;
helper def : recieverArgument1 : forsyde!ProcessArgument = OclUndefined;

helper def : resolvePorts (p: Sequence(forsyde!Port) , pr:Sequence(forsyde!Process)) : Sequence (forsyde!Port) =
	  		p ->collect (k | if (k.name.endsWith('prime')) then
	  													 if k.oclIsTypeOf(forsyde!InputPort) then
														 			thisModule.resolvePortsTempIn(k,pr->
														 				select(m|  (m.name = (k.name)))->first())
	  													  else
														 			thisModule.resolvePortsTempOut(k,pr->
														 				select(m|  (m.name = (k.name)))->first())
	  													   endif
	  															else

	  																if k.oclIsTypeOf(forsyde!InputPort) then
																	thisModule.CopyInputPort(k)
																	else
																	thisModule.CopyOutputPort(k)
																	endif
	  						 endif )

			;
